// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: 2023-Present The peppr Authors
import { clone } from "ramda";
import { Capability } from "./capability";
import { Controller } from "./controller";
import { ValidateError } from "./errors";
import { AdmissionRequest, MutateResponse, ValidateResponse, WebhookIgnore } from "./k8s";
import { CapabilityExport } from "./types";
import { setupWatch } from "./watch-processor";
import { Log } from "../lib";

/** Custom Labels Type for package.json */
export interface CustomLabels {
  namespace?: Record<string, string>;
}
/** Global configuration for the peppr runtime. */
export type ModuleConfig = {
  /** The peppr version this module uses */
  pepprVersion?: string;
  /** The user-defined version of the module */
  appVersion?: string;
  /** A unique identifier for this peppr module. This is automatically generated by peppr. */
  uuid: string;
  /** A description of the peppr module and what it does. */
  description?: string;
  /** The webhookTimeout */
  webhookTimeout?: number;
  /** Reject K8s resource AdmissionRequests on error. */
  onError?: string;
  /** Configure global exclusions that will never be processed by peppr. */
  alwaysIgnore: WebhookIgnore;
  /** Define the log level for the in-cluster controllers */
  logLevel?: string;
  /** Propagate env variables to in-cluster controllers */
  env?: Record<string, string>;
  /** Custom Labels for Kubernetes Objects */
  customLabels?: CustomLabels;
};

export type PackageJSON = {
  description: string;
  peppr: ModuleConfig;
};

export type pepprModuleOptions = {
  deferStart?: boolean;

  /** A user-defined callback to pre-process or intercept a peppr request from K8s immediately before it is processed */
  beforeHook?: (req: AdmissionRequest) => void;

  /** A user-defined callback to post-process or intercept a peppr response just before it is returned to K8s */
  afterHook?: (res: MutateResponse | ValidateResponse) => void;
};

// Track if this is a watch mode controller
export const isWatchMode = () => process.env.peppr_WATCH_MODE === "true";

// Track if peppr is running in build mode
export const isBuildMode = () => process.env.peppr_MODE === "build";

export const isDevMode = () => process.env.peppr_MODE === "dev";

export class pepprModule {
  #controller!: Controller;

  /**
   * Create a new peppr runtime
   *
   * @param config The configuration for the peppr runtime
   * @param capabilities The capabilities to be loaded into the peppr runtime
   * @param opts Options for the peppr runtime
   */
  constructor({ description, peppr }: PackageJSON, capabilities: Capability[] = [], opts: pepprModuleOptions = {}) {
    const config: ModuleConfig = clone(peppr);
    config.description = description;

    // Need to validate at runtime since TS gets sad about parsing the package.json
    ValidateError(config.onError);

    // Handle build mode
    if (isBuildMode()) {
      // Fail if process.send is not defined
      if (!process.send) {
        throw new Error("process.send is not defined");
      }

      const exportedCapabilities: CapabilityExport[] = [];

      // Send capability map to parent process
      for (const capability of capabilities) {
        // Convert the capability to a capability config
        exportedCapabilities.push({
          name: capability.name,
          description: capability.description,
          namespaces: capability.namespaces,
          bindings: capability.bindings,
          hasSchedule: capability.hasSchedule,
        });
      }

      // Send the capabilities back to the parent process
      process.send(exportedCapabilities);

      return;
    }

    this.#controller = new Controller(config, capabilities, opts.beforeHook, opts.afterHook, () => {
      // Wait for the controller to be ready before setting up watches
      if (isWatchMode() || isDevMode()) {
        try {
          setupWatch(capabilities);
        } catch (e) {
          Log.error(e, "Error setting up watch");
          process.exit(1);
        }
      }
    });

    // Stop processing if deferStart is set to true
    if (opts.deferStart) {
      return;
    }

    this.start();
  }

  /**
   * Start the peppr runtime manually.
   * Normally this is called automatically when the peppr module is instantiated, but can be called manually if `deferStart` is set to `true` in the constructor.
   *
   * @param port
   */
  start = (port = 3000) => {
    this.#controller.startServer(port);
  };
}
